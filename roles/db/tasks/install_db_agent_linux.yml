---
- name: DB Agent Linux Block
  become: true
  block:
    - include_tasks: appd_sudoer.yml

    - include_tasks: install_java_linux.yml
      when: install_jre is undefined or install_jre

    - name: Ensures DB agent dir exists
      file:
        path: "{{ db_agent_dest_folder_linux }}/"
        state: directory
        mode: 0755
        owner: "{{ appdynamics_user }}"
        group: "{{ appdynamics_user }}"
        recurse: yes
      changed_when: false # this ensures this task is idempotent

    - name: Clean out orphanned {{ db_agent_dest_file }}
      file:
        path: "{{ db_agent_dest_folder_linux }}/{{ db_agent_dest_file }}"
        state: absent
      changed_when: false # this ensures this task is idempotent

    - name: Check if DB agent exists
      stat:
        path: "{{ db_agent_dest_folder_linux }}/db-agent.jar"
      register: previous_db_agent

    - name: Backup old DB agent to /tmp folder
      archive:
        path: "{{ db_agent_dest_folder_linux }}"
        dest: "/tmp/db_agent.{{ ansible_date_time.iso8601 }}.zip"
        mode: 0755
      when: previous_db_agent.stat.exists
      changed_when: false

    - name: Get running DB processes
      shell: "ps -ef | grep -v grep | grep -w 'db-agent' | awk '{print $2}'"
      register: running_processes
      when: previous_db_agent.stat.exists
      changed_when: false

    - debug:
        msg: "{{ running_processes.stdout_lines }}"
      when: previous_db_agent.stat.exists
      changed_when: false

    - name: Kill running DB processes
      command: "kill {{ item }}"
      with_items: "{{ running_processes.stdout_lines }}"
      ignore_errors: yes  # Skip 'kill: No such process' errors
      when: previous_db_agent.stat.exists
      changed_when: false

    - name: Force Kill DB process
      wait_for:
        path: "/proc/{{ item }}/status"
        state: absent
      with_items: "{{ running_processes.stdout_lines }}"
      ignore_errors: yes
      register: killed_processes
      when: previous_db_agent.stat.exists
      changed_when: false

    - debug:
       msg: "{{ running_processes.stdout_lines }}"
      when: previous_db_agent.stat.exists
      changed_when: false

    - name: Force kill stuck processes
      command: "kill -9 {{ item }}"
      with_items: "{{ killed_processes.results | select('failed') | map(attribute='item') | list }}"
      when: previous_db_agent.stat.exists
      changed_when: false

    - name: Clean up old DB Agent binaries after backup
      file:
        path: "{{ db_agent_dest_folder_linux }}"
        state: absent
      changed_when: false

    - name: Ensures DB agent dir exists
      file:
        path: "{{ db_agent_dest_folder_linux }}/"
        state: directory
        mode: 0755
        owner: "{{ appdynamics_user }}"
        group: "{{ appdynamics_user }}"
        recurse: yes
      changed_when: false # this ensures this task is idempotent

    - name: Download DB Agent
      get_url:
        url: "{{ agent_download_url.stdout }}"
        dest: "{{ db_agent_dest_folder_linux }}/{{ db_agent_dest_file }}"
        force: true # download a new file even if dbagent.zip exists.
      changed_when: false
      register: result
      failed_when: result.status_code != 200

    - debug:
        msg: "{{ result }}"

    - name: Unzip DB agent file
      unarchive:
        #src: "{{ agent_download_url.stdout }}"
        src: "{{ db_agent_dest_folder_linux }}/{{ db_agent_dest_file }}"
        dest: "{{ db_agent_dest_folder_linux }}"
        owner: "{{ appdynamics_user }}"
        group: "{{ appdynamics_user }}"
        mode: 0755
        remote_src: yes
      changed_when: false

    - name: Configure db-agent controller-info.xml file
      template:
        src: templates/db-agent-controller-info.xml.j2
        dest: '{{ db_agent_dest_folder_linux }}/conf/controller-info.xml'
        owner: "{{ appdynamics_user }}"
        group: "{{ appdynamics_user }}"
        mode: 0755
      changed_when: false

    # --------------------------------------------------------------------------
    # Update the Log4j setting to apply the desired log level to all the loggers
    # listed in the {{agent_loggers}} that need to be matched. The XML module
    # requires that tags and attributes be present if changes are to be applied
    # For this reason, we first look for all mataches and then apply the changes
    - name: Set the log level on the agent (if != info, which it is by default)
      become: false
      block:
      - debug:
          msg: "Requested log level = {{ agent_log_level }} - Logger = {{ agent_loggers }}"

      - name: Create a local directory to manipulate the log4j file
        tempfile:
          state: directory
          suffix: build
        register: tempDir
        changed_when: false

      # Rather than modifying the XML files in-situ on the remote server, re copy
      # tem down and do the XML manipulation locally. This is done so we can
      # use the xml module without the need to install lxml of pip on the
      # target server.
      - name: Copy the log4j file down to update it localy
        fetch:
          src: '{{ db_agent_dest_folder_linux }}/conf/logging/log4j.xml'
          dest: '{{ tempDir.path }}/'
          mode: 0755
          flat: yes
        changed_when: false

      - name: Check which xpath entries are found
        xml:
          # path: '{{ db_agent_dest_folder_linux }}/conf/logging/log4j.xml'
          path: '{{ tempDir.path }}/log4j.xml'
          xpath: //logger[@name='{{ item }}']/level
          count: yes
        register: hits
        delegate_to: localhost
        loop: "{{ agent_loggers }}"

      - name: Set the log DB level for all relevant loggers
        xml:
          # path: '{{ db_agent_dest_folder_linux }}/conf/logging/log4j.xml'
          path: '{{ tempDir.path }}/log4j.xml'
          xpath: "{{ item.actions.xpath }}" # //logger[@name='{{ item }}']/level
          attribute: value
          value: "{{ agent_log_level }}"
        loop: "{{ hits.results }}" # "{{ agent_loggers }}"
        delegate_to: localhost
        when: item.count >= 1

      - name: Copy the local file back to the host
        become: true
        copy:
           src: '{{ tempDir.path }}/log4j.xml'
           dest: '{{ db_agent_dest_folder_linux }}/conf/logging/log4j.xml'
        changed_when: false

      - name: Delete the temp directory
        file:
           path: "{{ tempDir.path }}"
           state: absent
        delegate_to: localhost
        changed_when: false
      when: agent_log_level|lower != 'info'
    # --------------------------------------------------------------------------

    - name: Add the DB Agent as a Service using Systemd
      template:
        src: templates/appdynamics-db-agent.service.j2
        dest: /etc/systemd/system/appdynamics-db-agent.service
        force: true
        owner: root # The Machine Agent must not run as root, you may change it.
        group: root
        mode: 0644
      register: db_agent_systemd_result

    - name: Enable the DB Agent to start at system startup
      systemd:
        name: appdynamics-db-agent
        enabled: yes
        force: true # Force it to override existing symlink incase of an upgrade
        masked: no

    - name: Start the agent service
      systemd:
        name: appdynamics-db-agent
        state: started
        daemon_reload: yes
      changed_when: false

    - name: Make sure the service is running
      shell: systemctl status appdynamics-db-agent
      register: result
      ignore_errors: yes
      changed_when: false

    - name: Show DB Agent status
      debug:
        var: result

    #- name: Start DB Agent service
     #  shell: "nohup java -Dappdynamics.agent.uniqueHostId={{ host_name }} -Ddbagent.name={{ db_agent_name }} -Xms1536m -jar {{ db_agent_dest_folder_linux }}/db-agent.jar </dev/null >/dev/null 2>&1 &"
      #shell: "{{ db_agent_dest_folder_linux }}/start-dbagent  -Dappdynamics.agent.uniqueHostId={{ host_name }} -Ddbagent.name={{ db_agent_name }} -Xms1536m  </dev/null >/dev/null 2>&1 &"

    - name: Get new running DB processes
      shell: "ps -ef | grep -v grep | grep -w 'db-agent' | awk '{print $2}'"
      register: db_proc
      changed_when: false

    - debug:
       msg: "{{ db_proc.stdout_lines }}"

    - name: "Validate DB PID"
      assert:
         that:  db_proc.stdout_lines | first | length != 0
         msg:  "DB PID must be present"
      when: lookup('env', 'MOLECULE_FILE') is not defined

    - name: Clean up
      file:
        path: "{{ db_agent_dest_folder_linux }}/{{ db_agent_dest_file }}"
        state: absent
      changed_when: false
